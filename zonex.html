<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Zone:X - Sonic Starship</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
<script src="./three.min.js"></script>

		<div id="container"></div>

		<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 vUv;
        		uniform vec2 coords;
       			uniform vec2 resolution;
       			uniform float time;

			void main()	{

				vUv = uv;
				gl_Position = vec4( position, 1.0 );
			}
		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">

			varying vec2 vUv;
			uniform vec2 coords;
       			uniform vec2 resolution;
			uniform float time;

void main(){

	vec2 p=-((vUv.yx)-.5)/(resolution.xy/min(resolution.x,resolution.y))*18.*time;
p+=coords.yx;
vec2 s=p;
float l=1.;
for (int f=0;f<90;f+=1)if(abs(s.x+s.y)>17.)l=0.;
else s=vec2((s.x*s.x-s.y*s.y-p.x),2.0*s.x*s.y-p.y);
gl_FragColor=vec4(l);}

		</script>

		<script>
		
	/*	
function hsv2rgb (var hsv) {
  // from HSV to RGB color vector
  hsv.yz = clamp (hsv[1],hsv[2], 0.0, 1.0);
  return hsv[2] * (1.0 + 0.63 * hsv[1]] * (-cos (2.0 * 3.14159 * (hsv[0]] + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));
}//^^^^^^above from https://shadertoy.fandom.com/wiki/Color_Processing^^^^^//modified by X
*/

		var pi = 3.14159
var testar = Array(24);
var testarD = Array(24);
    var maxFreq = 0;
var mamp = -1000000;
	var averagedAmp =  0;
	
	var len=0;
	var spirray0 = Array(2000);
	var spirray1 = Array(2000);
	var spiregulator=0;
	var phase = 0;
function makeSpirograph()
    {
        		phase = phase % (pi*2);
        len = 0;
        linx= inputData.length;
        var adjConstant = 1./(spirafreq)*3.14*1.618;
        //linx*=440./pitc;
       // if (linx >1100)linx = 1100;
        for(var m = 0; m < linx/1.1; m++)
        {
            if ( inputData[m]!=0 || isFinite(inputData[m]) ) 
            {

                var samp = inputData[m];
                phase += adjConstant;//spira_pitch;
                spirray0[len]=-Math.sin(phase)*samp;
                spirray1[len]=-Math.cos(phase)*samp;
                len++;
            }
        }
       
        len -= 1;
        largest_loop = 0;
        spiregulator = 0;
        for(var f = 0; f<len; f++)
        {

            if (Math.abs(spirray0[f])>largest_loop)largest_loop =
                                                             Math.abs(spirray0[f]);
            if (Math.abs(spirray1[f])>largest_loop)largest_loop =
                                                        Math.abs(spirray1[f]);
        }
        spiregulator=largest_loop*2;//*on;

    }

    function spiral_compress()
    {
        maxFreq = 0;
        var freq = 0;
        max1 = -100000;
        min1 = 100000;
		 mamp = -1000000;
        for(var n = 0; n<24; n++){testar[n] = 0;testarD[n] = 1;}
    
        var b = -1000000;
z = dataArray;
	 averagedAmp =  0;
        for(var t=1; t<1024; t+=1)//n<fftSize1/4-100
        {
            var n =t;
            //if (fftSize1/4<t) n =Math.abs(t-var(t)/(var(fftSize1/4)));

averagedAmp += z[n];
        if ( z[n]>z[n-1] && z[n] > z[n+1] )
            {

                var   d = (-z[n-1]+z[n+1])/(z[n-1]+z[n+1]);

                var nAdj = n;
                if (Math.abs(d)<1.1) nAdj = n + d;           
                //if (Math.abs(nAdj-n) < 10)
                freq =((( audioX.sampleRate /10000.)*(nAdj))/1024)*10000;


                {
                    var g = Math.pow ( 2, (1/24.));
                    var aa = freq/440.0;
                    var note = Math.log(aa)/Math.log(g)+69*2;
                    testar[(Math.round(note))%24] += Math.abs(z[n]);
                    testarD[(Math.round(note))%24] += 1;

                }
            }
        }

averagedAmp/=1000.;
    };

var time = 0;
    var maxInt24 = 0;
    var maxWave = 0;
  //  for(var n = 0; n<audiBuffer.length; n++)
///b = abs(-sin(n/audiBuffer.length*(pi*2.)));

	var shrinking, moving;
	var coordX=0.;
	var coordY=0.;
	var part = {cx : {  value: 0 },};
	var trail = Array(1000);
		var cx = Array(1000);
				var cy = Array(1000);
						var pitchCol = Array(1000);
   var trailLoaded = false;
   var trailDepth = -1;
      var trailLength = 144;
      var d_x=0,d_y=0;
      var f = 0;
      
      

                      var xPerp= Array(1000);
                      var yPerp = Array(1000);
                      var angle=Array(1000);
                      var MIN_SAMPLES = 0;  // will be initialized when AudioContext is created.

var pitc = 1;
 var inputData;
var nullresult= 0;
var  jankedNotes=0;
var bufferSize = 1024;
var reset = 0;
var on;
var spirafreq=1;
    function  move()
    {   

    if (!trailLoaded) {trailLoaded = true; for(var n = 0; n<trailLength; n++) trail[n] = part;xPerp[n]=0;yPerp[n]=0;angle[n]=0;cx[n]=0;cy[n]=0;}

      inputData = new Float32Array(bufferSize);
    
     analyser.getFloatTimeDomainData(inputData); // fill the Float32Array with data returned from getFloatTimeDomainData() 
		//var iD = Array(inputData.length);
		//for(var m = 0; m<inputData.length; m++) iD[m]=(inputData[m]);
		 var pb = -1;

      if(inputData[0]>0.01)
       pb =    calculatePitch();
       pt = pb;
       if(pb>0){pb =Math.pow(pb,.5)*.75;}
       var volumeModifier = dataArray[0];
on = 1;

if (isFinite(pb) &&pb>0&& pb!=23.988278387579214 &&pb!=1) {spirafreq=pt;pitc =pb;reset =0;}
else if (reset>5){averagedAmp =0;on = 0;spirafreq=pt}
else reset++

			{
if (trailDepth<trailLength)trailDepth++;

        var magnitude=.1;

        radius = magnitude;

            var g = Math.pow ( 2, (1/24.0));
            var aa = pitc/440.0;
            var note = Math.log(aa)/Math.log(g)+49;
            var inc = 4;
            var t =  (-note * 30+30*inc);
            angle = t%360;
            angle = -angle;
	var vo = new THREE.Color();
				b = vo.setHSL((angle+90)/360.,1.,.5);
            pitchCol[f]  = new THREE.MeshBasicMaterial( { color:vo});
			     angle = ((angle-30+180)/360*2*pi);
           // angle = (maxInt24/24*2*pi);
            angle[f] = angle;

            //Colour pitchCol = Colour::fromHSV((angle-60)/360.,saturation,value,1.);
			

            d_x = -Math.sin(-angle)*averagedAmp**.777/2.; 
            d_y = -Math.cos(-angle)*averagedAmp**.777/2.;
            if(isFinite(d_x)&&isFinite(d_y)){coordX+=d_x*.02*zoom;
            coordY+=d_y*.02*zoom;}


         interpolationFactor = 10.;//timeDif*1./(callbackWait-1);
        if (interpolationFactor>30) interpolationFactor=30;
        else if (interpolationFactor<1) interpolationFactor=1;

           cx[f] = 0;
            cy[f] = 0;
                 xPerp[f] = -Math.sin(-angle+pi/2);
                yPerp[f] = -Math.cos(-angle+pi/2);
                trail[f].radii = radius/2;

                
			f++;
			if (f>=trailDepth)f=0;

        for(var n = 0; n < trailDepth; n++)
        {
            cx[n] += d_x;
            cy[n] += d_y;
            }

    }
}


var material;
			var container;
			var camera, renderer;
var mesh;
var micTexture;
var analyser;
var source;
var dataArray;
startMic();
var geometries = Array(24);
var meshes = Array(24);
var zoom=1.;
var trailGeom = Array(1000);
var materials = Array(1000);
var trailMeshes = Array(1000);
var materialShader;
var geometry;
var progress = true;
window.addEventListener('keydown', function(event) {
var x = parseInt(String.fromCharCode(event.which || event.keyCode));
//if (x>0)
				//renderer.setPixelRatio( window.devicePixelRatio /x);
}, false);



var uniforms;
			function init() {

				container = document.getElementById( 'container' );
				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

				
				 geometry = new THREE.PlaneBufferGeometry( 2, 2 );


for (var r=0; r<24; r++) {

	var vo = new THREE.Color();
				b = vo.setHSL((r-10)%24/24.,1.,.5);
            material  = new THREE.MeshBasicMaterial( { color:vo});
            
var vertices = new Float32Array( [0,0,0,
0,0,0,
0,0,0
] );
geometries[r] = new THREE.BufferGeometry();
geometries[r].addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );

            
meshes[r] = new THREE.Mesh(geometries[r] , material );

	}	

for (var r=0; r<trailLength; r++) {

 materials[r] = new THREE.MeshBasicMaterial( { color: 0x0000f0 } );
var vertices = new Float32Array( [0,0,0,
0,0,0,
0,0,0
] );

trailGeom[r] = new THREE.BufferGeometry();
trailGeom[r].addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
trailMeshes[r] = new THREE.Mesh(trailGeom[r] , materials[r] );


	}	
uniforms = THREE.UniformsUtils.merge([
  	  THREE.UniformsLib.lights, 
  {
					micIn : {  value: null }, // float array (vec3)
        time: {value: 1.0 },
        resolution: {value: new THREE.Vector2() },
        coords: {value: new THREE.Vector2() }
}
  ]);
      uniforms.resolution.value.x = window.innerWidth;
      uniforms.resolution.value.y = window.innerHeight;
      uniforms.coords.value.x = coordX;
      uniforms.coords.value.y = coordY;
				 materialShader = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent
				} );
		
				renderer = new THREE.WebGLRenderer();




				renderer.setPixelRatio( window.devicePixelRatio);

				container.appendChild( renderer.domElement );
				onWindowResize();
				window.addEventListener( 'resize', onWindowResize, false );
			animate();
			}
			function onWindowResize() {

      uniforms.resolution.value.x = window.innerWidth;
      uniforms.resolution.value.y = window.innerHeight;
				renderer.setSize( window.innerWidth, window.innerHeight );
				
				


			}
			//
			
			//
			
		

			function animate( timestamp ) {
			
spiral_compress();

move();
			makeSpirograph();
			var lineMat = new THREE.LineBasicMaterial( {
	color: 0x777777,
	linewidth: 3,
	linecap: 'round', //ignored by WebGLRenderer
	linejoin:  'round' //ignored by WebGLRenderer
} );
			var point = new THREE.Geometry();
var porportion = window.innerHeight/ window.innerWidth;
  for (var r= 0; r < len; r ++) {
                var tx = spirray0[r]*porportion/spiregulator;
                var ty =  spirray1[r]/spiregulator;
//if (r == 0) console.log(tx);
//	if(!(isFinite(tx) || isFinite(ty) || Math.abs(tx)>window.innerWidth/2 || Math.abs(cy)>window.innerHeight/2))

		if (isFinite(tx)&&isFinite(ty)) point.vertices.push(
 new THREE.Vector3( tx, ty, -0.07 )
);

	}	 

 var line = new THREE.Line( point, lineMat );
			var	scene = new THREE.Scene();
				             scene.add(line);

			if (zoom>.000001&&progress){ zoom /= 1.005;}
			else if (zoom<1.0){progress = false;zoom *= 1.1;}
			else {progress = true;}
      uniforms.coords.value.x = coordX;
      uniforms.coords.value.y = coordY;
      				//uniforms[ "time" ].value = timestamp / 1000;
      uniforms[ "time" ].value = zoom;
				requestAnimationFrame( animate );
if (micOn)analyser.getByteFrequencyData(  dataArray); 


for (var g=0; g<24; g++) {
var widt = .02;
var r = (g+14)%24;
var lengt = .1*testar[(r+4)%24]/200.;

	var vo = new THREE.Color();
				b = vo.setHSL((20-r)%24/24.,1.,.5);
            material  = new THREE.MeshBasicMaterial( { color:vo});
meshes[r] = new THREE.Mesh(geometries[r] , material );
scene.add(meshes[r])

var vertices = new Float32Array( [
	0-widt*-Math.sin(r*pi*2./24+pi/2.)*porportion,	0-widt*-Math.cos(r*pi*2./24+pi/2.),  -0.05, 
	0+widt*-Math.sin(r*pi*2./24+pi/2.)*porportion,	0+widt*-Math.cos(r*pi*2./24+pi/2.),  -0.05, 
	(lengt*-Math.sin(r*pi*2./24)+widt*-Math.sin(r*pi*2./24+pi/2.))*porportion,	
	lengt*-Math.cos(r*pi*2./24)+widt*-Math.cos(r*pi*2./24+pi/2.),  -0.05, 
	0-widt*-Math.sin(r*pi*2./24+pi/2.)*porportion,	0-widt*-Math.cos(r*pi*2./24+pi/2.),  -0.05, 
	(lengt*-Math.sin(r*pi*2./24)+widt*-Math.sin(r*pi*2./24+pi/2.))*porportion,	
	lengt*-Math.cos(r*pi*2./24)+widt*-Math.cos(r*pi*2./24+pi/2.),  -0.05, 
	(lengt*-Math.sin(r*pi*2./24)-widt*-Math.sin(r*pi*2./24+pi/2.))*porportion,	
	lengt*-Math.cos(r*pi*2./24)-widt*-Math.cos(r*pi*2./24+pi/2.),  -0.05, 
] );

// itemSize = 3 because there are 3 values (components) per vertex
geometries[r].addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );

	}	 
var r = (f+trailDepth-2)%trailDepth;
var s = (f+trailDepth-1)%trailDepth;
var loopLimit = trailDepth;
//if(isFinite(cx[r-1])&&isFinite(cx[s])&&isFinite(cy[r-1])&&isFinite(cy[s]))
while(loopLimit>15)
 {loopLimit--;

material = pitchCol[r];
trailMeshes[r] = new THREE.Mesh(trailGeom[r] , material );

 //material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
 //trailMeshes[s] = new THREE.Mesh(trailGeom[s] , material );
// create a simple square shape. We duplicate the top left and bottom right
// vertices because each vertex needs to appear once per triangle.
var widtr = .2*(trailDepth-loopLimit)/trailDepth;
var widts = .2*(trailDepth-loopLimit-1)/trailDepth;
var scalar = .005;//mobius mode: var scalar = .07*loopLimit/trailDepth;
var tt = 0.;
var vertices = new Float32Array( [
(scalar*cx[r]+widtr*xPerp[r])*porportion, scalar*cy[r]+widtr*yPerp[r],-.1,
		                            ( scalar*cx[s]-widts*xPerp[s])*porportion, scalar*cy[s]-widts*yPerp[s],-.1,
				(scalar*cx[s]+widts*xPerp[s])*porportion, scalar*cy[s]+widts*yPerp[s],-.1,
						         ( scalar*cx[r]-widtr*xPerp[r])*porportion, scalar*cy[r]-widtr*yPerp[r],-.1, //2
								                       (scalar*cx[s]-widts*xPerp[s])*porportion, scalar*cy[s]-widts*yPerp[s],-.1,  //1
		                            					(scalar*cx[r]+widtr*xPerp[r])*porportion, scalar*cy[r]+widtr*yPerp[r],-.1, //3
		                            					

] );

trailGeom[r].addAttribute( 'position', new THREE.Float32BufferAttribute( vertices,3 ) );
	scene.add(trailMeshes[r])
	s = r;
	r--;
	
	if(r<=0)r=trailDepth-1;

}


		 mesh = new THREE.Mesh( geometry, materialShader );
				scene.add( mesh );
				renderer.render( scene, camera );
			  // scene1.add( scene );

			scene.dispose();
									point.dispose();
for (var r=0; r<24; r++) geometries[r].dispose();
for (var r=0; r<trailDepth; r++){ trailGeom[r].dispose();}
			}

			
 var audioX;
var micOn = false;
async function startMic() {
  let stream = null;



    stream = await navigator.mediaDevices.getUserMedia({audio: true}).then(

 function (stream){
 micOn = true;
       audioX = new AudioContext();
      analyser = audioX.createAnalyser();
      source = audioX.createMediaStreamSource( stream );
      source.connect(analyser);
      analyser.fftSize = 2048.;
      bufferLength = analyser.frequencyBinCount;
      dataArray = new Uint8Array( bufferLength );
      init();
}
);	
}

    //begin MIT license
    /** Full YIN algorithm */
    function calculatePitch () 
    {
  var yinData = Array(bufferSize/2);
        var period;
        var delta = 0.0, runningSum = 0.0;
        yinData[0] = 1.0;
        for (var tau = 1; tau < yinData.length; tau++)
        {

            yinData[tau] = 0.0;
            for (var j = 0; j < yinData.length; j++)
            {
                delta = inputData[j] - inputData[j + tau];            
               if(isFinite(delta)) yinData[tau] += (delta * delta);
            }
            runningSum += yinData[tau];
            if (runningSum != 0)
            {
                yinData[tau] *= tau / runningSum;
            }
            else
            {
                yinData[tau] = 1.0;
            }
            period = tau - 3;


            if (tau > 4 && (yinData[period] < tolerance) &&
                    (yinData[period] < yinData[period + 1]))
            {
               return quadraticPeakPosition (yinData, period);
            }
        }
        return quadraticPeakPosition (yinData, minElement(yinData));
    }

 


    var tolerance=.3; //, confidence;
    var sampleRate=44100;
   function minElement (d) 
    {

        var j, pos = 0;
        var tmp = d[0];
        for (j = 0; j < bufferSize; j++)
        {
            pos = (tmp < d[j]) ? pos : j;
            tmp = (tmp < d[j]) ? tmp : d[j];
        }
  
        return pos;
    }    

    function quadraticPeakPosition (d, pos) 
    {
    
        var s0, s1, s2;
        var x0, x2;
        if (pos == 0 || pos == bufferSize - 1) return pos;
        x0 = (pos < 1) ? pos : pos - 1;
        x2 = (pos + 1 < bufferSize) ? pos + 1 : pos;
        if (x0 == pos) return (d[pos] <= d[x2]) ? pos : x2;
        if (x2 == pos) return (d[pos] <= d[x0]) ? pos : x0;
        s0 = d[x0];
        s1 = d[pos];
        s2 = d[x2];
        return pos + 0.5 * (s0 - s2 ) / (s0 - 2.* s1 + s2);
    }
//end MIT license
      




	</script>

	</body>
</html>
